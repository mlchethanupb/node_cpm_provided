#include <ros/ros.h>
#include <sys/socket.h>
#include <ctime>
#include <cstring>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <std_msgs/String.h>
#include <etsi_its_msgs/CPM.h>
#include <vector>
//#include <flatbuffers/all_interface_generated.h> // This was generated by `flatc`.
//#include "flatbuffers/all_interface_generated.h" // This was generated by `flatc`.
#include "all_interface_generated.h" // This was generated by `flatc`.

using namespace Gos;

#define PORT 3000
#define BUFFER_SIZE 4096

//function declarations
void generateMessage(etsi_its_msgs::CPMConstPtr cpm_provided) ;
void construct_gossip_message(etsi_its_msgs::CPMConstPtr cpm_provided);
::flatbuffers::Offset<Gos::ManagementContainer> construct_mgmt_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm);
::flatbuffers::Offset<Gos::CpmPayload> construct_cpm_payload(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm);
::flatbuffers::Offset<Gos::OriginatingStationsContainer> construct_org_stn_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm);
::flatbuffers::Offset<Gos::OriginatingVehicleContainer> construct_org_veh_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm);
::flatbuffers::Offset<Gos::OriginatingRSUContainer> construct_org_rsu_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm);
::flatbuffers::Offset<Gos::PerceivedObjectContainer> construct_prcvd_obj_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm);
::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceivedObject>>> create_list_of_prvd_obj(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm);
::flatbuffers::Offset<Gos::PerceivedObject> create_prvd_obj(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::PerceivedObject cpm);

// ROS callback function for the subscribed topic
void serialize_cpm(etsi_its_msgs::CPMConstPtr cpm)
{
    //std::cout << cpm->header.stamp << std::endl;

    ros::Duration diff = ros::Time::now() - cpm->header.stamp;
    ros::Time entry = ros::Time::now();

    //std::cout << "time diff: " << diff << ", " << entry << std::endl; 

    // @todo -- check for generation rules, then call function to serialize cpm 
    generateMessage(cpm);

    // Process the received message
    // ...
}


void generateMessage(etsi_its_msgs::CPMConstPtr cpm_provided) {

    construct_gossip_message(cpm_provided);
    sleep(1);
}



void construct_gossip_message(etsi_its_msgs::CPMConstPtr cpm){
   
    int sockfd;
    struct sockaddr_in server_addr, client_addr;
    //uint8_t buffer[BUFFER_SIZE];
    
    // Create a UDP socket
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }
    
    // Configure server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

   
    // ---------------------------------------------------------------------------------------------------------
      
    flatbuffers::FlatBufferBuilder builder;

    std::cout << "Building CPM for station id: " << cpm->its_header.station_id << std::endl;

    // header
    ::flatbuffers::Offset<Gos::ItsPduHeader> header = Gos::CreateItsPduHeader(builder,2, etsi_its_msgs::ItsPduHeader::MESSAGE_ID_CPM, cpm->its_header.station_id);
    
    //generation time
    ros::Time current_time = ros::Time::now();
    uint64_t gen_del_time = current_time.toNSec();
    std::cout << "generation time: " << gen_del_time << std::endl;


    auto mgmt_cntr = construct_mgmt_cntnr(builder, cpm);
    auto cpm_payload = construct_cpm_payload(builder, cpm);

    struct flatbuffers::Offset<Gos::CPMessage> cpm_msg = Gos::CreateCPMessage(builder,header,gen_del_time,mgmt_cntr,cpm_payload);
    flatbuffers::Offset<void> msgOption = cpm_msg.Union(); 
    ::flatbuffers::Offset<FacilityLayerReception> fac_reception_message = CreateFacilityLayerReception(builder,Gos::FacilityLayerMessage_CPMessage,msgOption);
    
    flatbuffers::Offset<void> gossip_option = fac_reception_message.Union();
    ::flatbuffers::Offset<GossipMessage> gossip_msg = CreateGossipMessage(builder,Gos::GossipType::GossipType_FacilityLayerReception,gossip_option);
    builder.Finish(gossip_msg);
    

    
    uint8_t* buffer = builder.GetBufferPointer();
    uint64_t size = 0;
    size = builder.GetSize();

    //Verify whether the buffer is valid
    flatbuffers::Verifier verifier(buffer, size);
    bool succ = VerifyGossipMessageBuffer(verifier);
    if (!succ) {
        std::cout << "buffer is invalid" << std::endl;
    }else{
        std::cout << "buffer is valid" << std::endl;
    }

    printf("Total size of the buffer %zu\n", size);

    // --------------------------------------------------------------------------------------------------------

    // Configure server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  // localhost

    if (sendto(sockfd, buffer, size, 0, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("Message sent to the server!\n");
}

::flatbuffers::Offset<ManagementContainer> construct_mgmt_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr ptr){

    //reference position
    ::flatbuffers::Offset<Gos::PositionConfidenceEllipse> pos_conf = Gos::CreatePositionConfidenceEllipse(builder,
                                                                                                          ptr->reference_position.position_confidence.semi_major_confidence,  
                                                                                                          ptr->reference_position.position_confidence.semi_minor_confidence,
                                                                                                           ptr->reference_position.position_confidence.semi_major_orientation);
    ::flatbuffers::Offset<Gos::Altitude> altitude = Gos::CreateAltitude(builder, ptr->reference_position.altitude.value, ptr->reference_position.altitude.confidence);
    ::flatbuffers::Offset<ReferencePosition> ref_pos = Gos::CreateReferencePosition(builder, ptr->reference_position.latitude, ptr->reference_position.longitude, pos_conf, altitude);

    //station type
    Gos::StationType stn_type = static_cast<Gos::StationType>(ptr->station_type.value);

        //generation time
    ros::Time current_time = ros::Time::now();
    uint64_t reference_time = current_time.toNSec();

    //managment container
    ::flatbuffers::Offset<ManagementContainer> mgmt_cntr = Gos::CreateManagementContainer(builder, reference_time,ref_pos,stn_type);

    return mgmt_cntr;
}

::flatbuffers::Offset<CpmPayload> construct_cpm_payload(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm){

    auto org_stn_cntnr = construct_org_stn_cntnr(builder, cpm);
    auto prcvd_obj_cntnr = construct_prcvd_obj_cntnr(builder, cpm);
    
    ::flatbuffers::Offset<CpmPayload> cpm_payload = CreateCpmPayload(builder, org_stn_cntnr, prcvd_obj_cntnr);

    return cpm_payload;
}

::flatbuffers::Offset<OriginatingStationsContainer> construct_org_stn_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm){

    auto veh_cntr = construct_org_veh_cntnr(builder, cpm);
    auto rsu_cntr = construct_org_rsu_cntnr(builder, cpm);
    
    ::flatbuffers::Offset<OriginatingStationsContainer> stn_cntr = CreateOriginatingStationsContainer(builder,veh_cntr,rsu_cntr);
    
    return stn_cntr;
}

::flatbuffers::Offset<OriginatingVehicleContainer> construct_org_veh_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr ptr){
    
    flatbuffers::Offset<Gos::Wgs84Angle> orientation_angle;
    if(ptr->originatingVehicleContainer.has_vehicleOrientationAngle){
        orientation_angle = CreateWgs84Angle(builder, 
                                             ptr->originatingVehicleContainer.vehicleOrientationAngle.value,
                                             ptr->originatingVehicleContainer.vehicleOrientationAngle.confidence);

    }else{
        orientation_angle = CreateWgs84Angle(builder, 0, 0);
    }

    //@todo -- check for related fields in the /cpm_provided
    auto pitch_angle = CreateCartesianAngle(builder, 456, 2);
    auto roll_angle = CreateCartesianAngle(builder, 789, 3);
    long trailer_dataset = 123456789;

    auto org_veh_cntr = CreateOriginatingVehicleContainer(builder,orientation_angle,pitch_angle,roll_angle,trailer_dataset);
   
    return org_veh_cntr;
}

::flatbuffers::Offset<OriginatingRSUContainer> construct_org_rsu_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr cpm){

    auto road_seg_info = CreateRoadSegmentReferenceID(builder, 123, 99);
    auto intrsctn_seg_info = CreateIntersectionReferenceID(builder, 987, 99);

    auto org_rsu_cntr = CreateOriginatingRSUContainer(builder, road_seg_info,intrsctn_seg_info);
    
    return org_rsu_cntr;
}



::flatbuffers::Offset<PerceivedObjectContainer> construct_prcvd_obj_cntnr(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr ptr){
    
    uint32_t num_of_prcd_objs =  ptr->numberOfPerceivedObjects;
    auto obj_list = create_list_of_prvd_obj(builder, ptr);
    
    ::flatbuffers::Offset<PerceivedObjectContainer> prcvd_obj_cntr = CreatePerceivedObjectContainer(builder, num_of_prcd_objs, obj_list);

    return prcvd_obj_cntr;
}

::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceivedObject>>> create_list_of_prvd_obj(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::CPMConstPtr ptr){
    
    //get the object list from the ros message and create the objects based on the information

    //code for decoding the ros message
    //add the collected information

    //dummy implementation now for testing
    std::vector<::flatbuffers::Offset<Gos::PerceivedObject>> objects_vector;
    for(auto obj_ptr : ptr->listOfPerceivedObjects.perceivedObjectContainer){
        ::flatbuffers::Offset<Gos::PerceivedObject> obj = create_prvd_obj(builder, obj_ptr); //temporary input for id (hence +1)
        objects_vector.push_back(obj);
    }
    auto prcvd_obj_list = builder.CreateVector(objects_vector);
    return prcvd_obj_list;
}

::flatbuffers::Offset<Gos::PerceivedObject> create_prvd_obj(flatbuffers::FlatBufferBuilder &builder, etsi_its_msgs::PerceivedObject obj){

    uint8_t obj_id = obj.objectID;
    int32_t delta_time = obj.timeOfMeasurement;
    
    //position
    using Coord_offset = ::flatbuffers::Offset<CartesianCoordinateWithConfidence>;
    Coord_offset x_cord = CreateCartesianCoordinateWithConfidence(builder, obj.xDistance.value,obj.xDistance.confidence);
    Coord_offset y_cord = CreateCartesianCoordinateWithConfidence(builder, obj.yDistance.value,obj.yDistance.confidence);
    Coord_offset z_cord = CreateCartesianCoordinateWithConfidence(builder, 1,1);
    ::flatbuffers::Offset<CartesianPosition3dWithConfidence> pos = CreateCartesianPosition3dWithConfidence(builder, x_cord,y_cord,z_cord);

    //velocity
    
        //VelocityPolarWithZ 
        ::flatbuffers::Offset<Speed> speed = CreateSpeed(builder, obj.xSpeed.value, (obj.xSpeed.confidence == 0) ? 127 : obj.xSpeed.confidence);     // @todo -- do x corresponds to speed and y corresponds to velocity
        ::flatbuffers::Offset<CartesianAngle> vel_dir = CreateCartesianAngle(builder,obj.ySpeed.value,(obj.ySpeed.confidence == 0) ? 127 : obj.xSpeed.confidence);
        ::flatbuffers::Offset<VelocityComponent> pol_z_vel = CreateVelocityComponent(builder,1,1); //@todo -- default values
        ::flatbuffers::Offset<VelocityPolarWithZ> pol_vel = CreateVelocityPolarWithZ(builder, speed, vel_dir, pol_z_vel);


        //VelocityCartesian
        using off_vel_com = ::flatbuffers::Offset<Gos::VelocityComponent>;
        off_vel_com x_vel = CreateVelocityComponent(builder, obj.xSpeed.value, (obj.xSpeed.confidence == 0) ? 127 : obj.xSpeed.confidence);
        off_vel_com y_vel = CreateVelocityComponent(builder, obj.ySpeed.value,(obj.ySpeed.confidence == 0) ? 127 : obj.xSpeed.confidence);
        off_vel_com z_vel = CreateVelocityComponent(builder, 1, 1);
        ::flatbuffers::Offset<Gos::VelocityCartesian> car_vel = CreateVelocityCartesian(builder, x_vel, y_vel, z_vel);

    ::flatbuffers::Offset<Velocity3dWithConfidence> vel = CreateVelocity3dWithConfidence(builder, pol_vel, car_vel);

   
    // Object Dimensions
    using offset_OD = ::flatbuffers::Offset<ObjectDimension>; 
    offset_OD o_dim_x = CreateObjectDimension(builder, obj.planarObjectDimension1.value, obj.planarObjectDimension1.confidence);
    offset_OD o_dim_y = CreateObjectDimension(builder, obj.planarObjectDimension2.value, obj.planarObjectDimension2.confidence);
    offset_OD o_dim_z = CreateObjectDimension(builder, obj.verticalObjectDimension.value, obj.verticalObjectDimension.confidence);

    //object age
    uint32_t obj_age = 32323;
    
    //classification
    std::vector<::flatbuffers::Offset<Gos::ObjectClassWithConfidence>> class_vec;
    uint8_t count = 1;
    for(uint8_t cls_cnt = 0 ; cls_cnt < count; cls_cnt++){

        auto obj_cls = CreateObjectClass(builder, static_cast<Gos::TrafficParticipantType>(obj.classification.value));
        ::flatbuffers::Offset<ObjectClassWithConfidence> obj_cls_conf = CreateObjectClassWithConfidence(builder, obj_cls, 100);
        class_vec.push_back(obj_cls_conf);
    }
    auto class_vec_offset = builder.CreateVector(class_vec);
    //map_position
        
        //map reference
        ::flatbuffers::Offset<RoadSegmentReferenceID> road_seg_id = CreateRoadSegmentReferenceID(builder, 93, 9343);
        ::flatbuffers::Offset<IntersectionReferenceID> intr_sec_id = CreateIntersectionReferenceID(builder, 342, 89);
        ::flatbuffers::Offset<MapReference> map_ref = CreateMapReference(builder, road_seg_id, intr_sec_id);

        uint32_t lane_id = 3;
        uint32_t conn_id = 4;

        //longitudinal position
        ::flatbuffers::Offset<LongitudinalLanePosition> longlane_pos = CreateLongitudinalLanePosition(builder, 2343, 898);

    ::flatbuffers::Offset<MapPosition> map_pos = CreateMapPosition(builder, map_ref,lane_id, conn_id, longlane_pos);

    ::flatbuffers::Offset<Gos::PerceivedObject> prcvd_obj = CreatePerceivedObject(builder, obj_id, delta_time, pos, vel, o_dim_x, o_dim_y, o_dim_z, obj_age, class_vec_offset, map_pos);

    return prcvd_obj;
}





int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, "node_cpm_provided");

    // Create a ROS node handle
    ros::NodeHandle nh;

    // Create a ROS subscriber
    ros::Subscriber sub = nh.subscribe("cpm_provided", 10, &serialize_cpm);

    // ROS main loop
    ros::spin();

    return 0;
}